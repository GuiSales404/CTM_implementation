"""
The selected strategy for up-tree competition of chunk generated by the processor and chunks generated from the input map employscycles of introspective and exploratory attention. 
This ensures a balanced focus between internal processing and external inputs, alternating between self-reflection and active monitoring of the environment.

One input chunk enter the LTM and the processors generate chunks based on the input.
The chunks compete in the up-tree, when a chunk wins and enter the STM, the chunk is availablel if it can be a answer/interaction with the user or
if the result of the chunk can be used to generate new chunks in the LTM to compete again until reach a acceptance state.
"""

import random
import string

from Chunk import Chunk
from DiscreteClock import DiscreteClock
from TreeNode import TreeNode
from ProcessorNode import ProcessorNode

class UpTree:
    _instance = None  
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super(UpTree, cls).__new__(cls)
            cls._instance._initialized = False  
        return cls._instance

    def __init__(self):
        if not self._initialized:
            self.stm = None
            self.ltm = None
            self.root = Chunk('root', 0, '', 0, 0, 0)
            self.leaves = None
            self.height = 0
            self._initialized = True 

    def _build_tree(self):
        if len(self.ltm.get_processors()) <= 0:
            return None
        
        self.leaves = self.ltm.get_processors()

        current_level = self.leaves
        
        count = 0
        
        while len(current_level) > 1:
            count += 1
            next_level = []
            
            for i in range(0, len(current_level), 2):
                parent = TreeNode(f'{i}_{random.choice(string.ascii_lowercase)}')
                parent.add_l(current_level[i])
                current_level[i].parent = parent
                if i + 1 < len(current_level):
                    parent.add_r(current_level[i+1])
                    current_level[i+1].parent = parent
                next_level.append(parent)
            current_level = next_level
            
        self.root = current_level[0]
        self.stm.set_chunk(current_level[0], first=True)
        self.height = count
        
    def configure(self, stm, ltm):
        self.stm = stm
        self.ltm = ltm
        self._build_tree()
        
    def _print_tree(self, node, level=0, side='root'):
        """
        This function is no longer used. It was previously used for debugging 
        when the UpTree was constructed with processors. Now, the tree is 
        formed only by chunks.
        Args:
            node (Node): The current node in the tree.
            level (int, optional): The current level in the tree. Defaults to 0.
            side (str, optional): The side of the node ('root', 'left', 'right'). Defaults to 'root'.
        """
        if node:
            if isinstance(node, ProcessorNode):
                print(" " * (level * 4) + f"{side}: Processor {node.address}")
            else:
                print(" " * (level * 4) + f"{side}: {node.address}")
                self._print_tree(node.child_left, level + 1, "left")
                self._print_tree(node.child_right, level + 1, "right")

    def coin_flip_neuron(self, a, b):
        elements = [a, b]
        if a == 0 and b == 0:
            probabilities = [0.5, 0.5]
        else:
            prob_a = a/(a+b)
            prob_b = 1 - prob_a
            probabilities = [prob_a, prob_b]
        return random.choices(elements, weights=probabilities, k=1)[0]
    
    def compete(self, level=None, run=1, new_root_name=None):
        DiscreteClock().increment_time()

        if level != None and len(level) == 1:
            self.root = level[0]
            self.stm.set_chunk(self.root)
            return
        
        if not level:
            level = self.leaves
            
        competitors = []
        winners = []
        for node in level:
            competitors.append(node)

            if len(competitors) == 2:
                gist_a = competitors[0]
                gist_b = competitors[1]
                winner_gist = self._competition_function(gist_a, gist_b)
                winners.append(winner_gist)
                print('\n-=-=-=-= competition:', run, '=-=-=-=-')
                print('\tcompetitors:', [comp.address for comp in competitors])
                print('\twinners:', [win.address for win in winners])
                competitors = []
        self.compete(winners, 1+run, winners[-1].address)

    def _competition_function(self, left_chunk, right_chunk):
        left_value = left_chunk.intensity + 0.5 * left_chunk.mood
        right_value = right_chunk.intensity + 0.5 * right_chunk.mood
        if left_value == self.coin_flip_neuron(left_value, right_value):
            selected_chunk = left_chunk
        else:
            selected_chunk = right_chunk
        return selected_chunk

    def get_winner(self):
        return self.root.data